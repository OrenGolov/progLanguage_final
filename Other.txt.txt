• Is your language is statically typed or dynamically typed? Explain in details 
your choice.

 The code represents a dynamically typed language. 
The code doesn't ask for the type of variables upfront and just figures out what they are as it goes along. Like, you don't have to say "this is a number" or "this is text," it just knows. Also, when it runs through the code, it doesn't check if what you're doing makes sense in terms of types before doing it. It just tries to do it and sees what happens. For instance, in the execute_statement part of the Interpreter class, it looks at what's there and deals with it on the spot without worrying about what type it is beforehand.


• Demonstrate the capabilities of the language by implementing an intricate 
program up to 50 lines long - Discussion of design decisions and trade-offs.

 Design Decisions:
    The Fibonacci code iteratively calculates Fibonacci numbers up to a certain limit and then identifies prime Fibonacci numbers among them.
    It uses a straightforward approach of calculating Fibonacci numbers iteratively using a while loop.
    It checks for prime numbers within the Fibonacci sequence using a basic primality check.
Trade-offs:
    This implementation sacrifices memory efficiency for simplicity by storing all Fibonacci numbers in a list. For very large inputs, this could lead to high memory consumption.


•For each milestone in the interpreter language, describe how converting to a compiled language affects the design and implementation.
 
 Milestone 1: Basic Arithmetic Operations:
    In a compiled language, the design would focus on generating machine code or intermediate representation directly from the provided grammar rules. This would involve
    building an abstract syntax tree (AST) and translating it into executable code.
 Milestone 2: Variables, Data Types, and Control Flows:
    Compilation would involve generating code to handle variables, data types, and control flows efficiently. This includes managing memory allocation, optimizing variable access, 
    and generating control flow instructions.
 Milestone 3: Memory Management and Boolean Expressions:
    Compilation would involve implementing memory management strategies such as garbage collection or manual memory allocation/deallocation. Boolean expressions would need to 
    be translated into machine-level instructions for evaluation.


• Explain how your language is imperative, detailing support for state, side effects, mutable data.
  
    Support for State: The language supports state through variables, which can hold mutable values that change during program execution.
    Side Effects: Operations such as assignments and arithmetic operations can have side effects, altering the state of variables and potentially affecting subsequent computations.
    Mutable Data: Variables in the language hold mutable data, allowing values to be modified during program execution.	


• Choose either the interpreted or compiled version. Describe in detail the changes needed to support object-oriented programming with polymorphism, inheritance, and encapsulation.


   To support object-oriented programming with polymorphism, inheritance, and encapsulation in the interpreted version of the language, several changes and additions are required:
   1.Polymorphism:
     Changes Needed:
        Introduce method overriding: Allow subclasses to provide their own implementation of methods inherited from superclasses.
        Implement dynamic method dispatch: Ensure that the appropriate method implementation is called based on the runtime type of the object.
     Implementation:
        Within the class definition, methods can be declared with the same signature as those in the superclass. When an overridden method is invoked on a subclass object, the subclass's
        implementation is executed instead of the superclass's implementation.
   2. Inheritance:
      Changes Needed:
        Introduce syntax for defining inheritance relationships between classes.
        Ensure that subclass objects inherit attributes and methods from their superclass.
      Implementation:
        Class definitions should include a mechanism to specify a superclass.
   3. Encapsulation:
      Changes Needed:
        Implement access control mechanisms to restrict access to class members (attributes and methods).
        Define public, private, and possibly protected access levels.
      Implementation:
        Syntax should be introduced within the class definition to specify the visibility of attributes and methods.


 • Support for Functional Programming:
	
   Interpreted Version:
    Functions can be treated as first-class citizens, allowing them to be passed as arguments, returned from other functions, and assigned to variables.
    Higher-order functions can be implemented, enabling functions to accept other functions as arguments or return functions as results.

 • Adapting to Logic Programming:

	Approach:

    -Logic Programming Basics: Understanding predicates, facts, and rules.
    -Backtracking Implementation: Developing efficient backtracking algorithms for exploring different paths.
    -Unification Techniques: Implementing unification to make different elements fit together logically.

	Challenges:
     - Adapting the language's underlying execution model to support logic programming.
     - Backtracking Efficiency: Ensuring efficient backtracking to explore various solution paths.
     - Addressing the complexity of unification algorithms and runtime support requirements.